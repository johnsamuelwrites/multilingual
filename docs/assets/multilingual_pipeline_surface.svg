<svg xmlns="http://www.w3.org/2000/svg" width="1280" height="760" viewBox="0 0 1280 760" role="img" aria-labelledby="title desc">
  <title id="title">Multilingual processing pipeline with optional surface normalization</title>
  <desc id="desc">Diagram showing source code flowing through lexer, optional surface normalizer, parser, semantic analyzer, Python code generator, and runtime execution, including async and try/except/else support in the shared pipeline.</desc>
  <defs>
    <style>
      .bg { fill: #f7f7f2; }
      .title { font: 700 32px 'Segoe UI', sans-serif; fill: #1f2937; }
      .subtitle { font: 500 18px 'Segoe UI', sans-serif; fill: #374151; }
      .label { font: 600 16px 'Segoe UI', sans-serif; fill: #111827; }
      .small { font: 500 14px 'Segoe UI', sans-serif; fill: #4b5563; }
      .box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 12; ry: 12; }
      .box-core { fill: #fffef7; stroke: #92400e; stroke-width: 2.5; rx: 12; ry: 12; }
      .box-optional { fill: #eff6ff; stroke: #1d4ed8; stroke-width: 2.5; rx: 12; ry: 12; }
      .box-runtime { fill: #ecfeff; stroke: #0f766e; stroke-width: 2.5; rx: 12; ry: 12; }
      .arrow { stroke: #374151; stroke-width: 2.5; fill: none; marker-end: url(#arrowHead); }
      .arrow-opt { stroke: #1d4ed8; stroke-width: 2.5; fill: none; marker-end: url(#arrowHeadBlue); }
      .dash { stroke-dasharray: 8 7; }
      .legend { fill: #ffffff; stroke: #94a3b8; stroke-width: 1.5; rx: 10; ry: 10; }
    </style>
    <marker id="arrowHead" markerWidth="10" markerHeight="8" refX="9" refY="4" orient="auto">
      <polygon points="0,0 10,4 0,8" fill="#374151" />
    </marker>
    <marker id="arrowHeadBlue" markerWidth="10" markerHeight="8" refX="9" refY="4" orient="auto">
      <polygon points="0,0 10,4 0,8" fill="#1d4ed8" />
    </marker>
  </defs>

  <rect class="bg" x="0" y="0" width="1280" height="760" />

  <text class="title" x="40" y="56">How multilingual Works (with Surface Normalization)</text>
  <text class="subtitle" x="40" y="88">One semantic core, optional language-specific surface rewrites, and shared AST/runtime behavior across languages.</text>

  <rect class="box" x="42" y="140" width="220" height="110" />
  <text class="label" x="62" y="176">Source .ml</text>
  <text class="small" x="62" y="203">Any supported language form:</text>
  <text class="small" x="62" y="224">canonical or alternate surface</text>

  <rect class="box-core" x="312" y="140" width="220" height="110" />
  <text class="label" x="332" y="176">Lexer</text>
  <text class="small" x="332" y="203">Tokenize Unicode text</text>
  <text class="small" x="332" y="224">Map keywords to concepts</text>

  <rect class="box-optional" x="582" y="112" width="270" height="166" />
  <text class="label" x="602" y="148">Surface Normalizer (optional)</text>
  <text class="small" x="602" y="175">Read rules from:</text>
  <text class="small" x="602" y="196">resources/usm/surface_patterns.json</text>
  <text class="small" x="602" y="223">Match token patterns</text>
  <text class="small" x="602" y="244">Rewrite to canonical concept order</text>
  <text class="small" x="602" y="265">Iterable-first pilot rules: ja, ar, es, pt</text>

  <rect class="box-core" x="902" y="140" width="220" height="110" />
  <text class="label" x="922" y="176">Parser</text>
  <text class="small" x="922" y="203">Build canonical AST</text>
  <text class="small" x="922" y="224">Language-agnostic grammar</text>

  <rect class="box-core" x="902" y="300" width="220" height="110" />
  <text class="label" x="922" y="336">Semantic Analyzer</text>
  <text class="small" x="922" y="363">Scope and symbol checks</text>
  <text class="small" x="922" y="384">Localized diagnostics</text>

  <rect class="box-core" x="902" y="460" width="220" height="110" />
  <text class="label" x="922" y="496">Python Code Generator</text>
  <text class="small" x="922" y="523">Emit deterministic Python</text>
  <text class="small" x="922" y="544">from the same AST model</text>

  <rect class="box-runtime" x="902" y="620" width="220" height="110" />
  <text class="label" x="922" y="656">Runtime / Executor / REPL</text>
  <text class="small" x="922" y="683">Execute generated Python</text>
  <text class="small" x="922" y="704">with localized builtins</text>

  <path class="arrow" d="M262 195 L312 195" />
  <path class="arrow-opt" d="M532 195 L582 195" />
  <path class="arrow" d="M852 195 L902 195" />
  <path class="arrow" d="M1012 250 L1012 300" />
  <path class="arrow" d="M1012 410 L1012 460" />
  <path class="arrow" d="M1012 570 L1012 620" />

  <path class="arrow dash" d="M532 250 C670 360, 800 360, 902 250" />
  <text class="small" x="602" y="360">No matching surface rule: pass through unchanged</text>

  <rect class="legend" x="42" y="300" width="810" height="282" />
  <text class="label" x="62" y="336">Concrete Example (Iterable-First Loop Normalization)</text>

  <rect class="box" x="62" y="356" width="360" height="200" />
  <text class="small" x="82" y="386">Input surface code</text>
  <text class="small" x="82" y="416">range(4) 内の 各 i に対して:</text>
  <text class="small" x="82" y="438">    合計 = 合計 + i</text>
  <text class="small" x="82" y="460">Equivalent surface variants exist for ar/es/pt.</text>

  <rect class="box-optional" x="462" y="356" width="370" height="200" />
  <text class="small" x="482" y="386">Pattern match captures:</text>
  <text class="small" x="482" y="416">iterable = range(4)</text>
  <text class="small" x="482" y="438">target = i</text>
  <text class="small" x="482" y="470">Template: for_iterable_first</text>
  <text class="small" x="482" y="500">Rewrite to canonical:</text>
  <text class="small" x="482" y="522">FOR target IN iterable :</text>

  <path class="arrow-opt" d="M422 456 L462 456" />

  <text class="small" x="42" y="608">Result: the parser and runtime only see canonical concept order, regardless of surface phrasing.</text>
</svg>


